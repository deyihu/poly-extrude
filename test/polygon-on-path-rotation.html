<!DOCTYPE html>
<html>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name=renderer content=webkit>
<script type="text/javascript" src="https://unpkg.com/@maptalks/geojson-bbox@1.0.4/dist/bbox.umd.js"></script>
<script type="text/javascript" src="https://unpkg.com/three@0.138.0/build/three.min.js"></script>
<script type="text/javascript" src="https://unpkg.com/three@0.142.0/examples/js/controls/OrbitControls.js"></script>
<script type="text/javascript" src="https://unpkg.com/poly-extrude/dist/poly-extrude.js"></script>
<script type="text/javascript" src="./util.js"></script>
<!-- <script type="text/javascript" src="http://localhost/geometry-extrude/dist/geometry-extrude.js"></script> -->

<style type="text/css">
    html,
    body {
        margin: 0px;
        height: 100%;
        width: 100%;
    }

    .container {
        width: 100%;
        height: 100%;
    }
</style>

<body>
    <script>
        const scene = createScene();

        function getTexture() {
            const texture = new THREE.TextureLoader().load('./data/a.png');
            texture.needsUpdate = true; //使用贴图时进行更新
            texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(8, 8);
            return texture;
        }

        const polygon = [
            [
                [6, 0],
                [0, -6,],
                [-6, 0],
                [0, 6],
            ]
        ]

        function scaleShape(polygon) {
            for (let i = 0, len = polygon.length; i < len; i++) {
                const ring = polygon[i];
                if (Array.isArray(ring[0])) {
                    scaleShape(ring);
                } else {
                    ring[0] /= 10;
                    ring[1] /= 10;
                }
            }
        }

        let extrudePath;
        let geometry;
        let polygonRotationAngle = 0;
        function createGeometry() {

            const result = polyextrude.extrudePolygonsOnPath([polygon], { extrudePath, openEnd: false, openEndUV: false, polygonRotation: polygonRotationAngle / 180 * Math.PI });
            // console.log(result);
            if (!geometry) {
                geometry = createBufferGeometry(result);
                const mesh = new THREE.Mesh(geometry, new THREE.MeshLambertMaterial({ color: '#FFF', wireframe: false, vertexColors: false, side: 2, map: getTexture() }));
                scene.add(mesh);
            } else {
                const { position, indices, normal, uv } = result;
                geometry.setAttribute('position', new THREE.BufferAttribute(position, 3));
                geometry.setAttribute('normal', new THREE.BufferAttribute(normal, 3));
                geometry.setAttribute('uv', new THREE.BufferAttribute(uv, 2));
                geometry.setIndex(new THREE.BufferAttribute(indices, 1));
            }

        }

        function animation() {
            polygonRotationAngle++;
            createGeometry();
            requestAnimationFrame(animation);
        }

        function test() {



            getGeoJSON('./data/simple-line.geojson').then(geojson1 => {
                flatCoordinates(geojson1);
                const feature = geojson1.features[0];

                extrudePath = feature.geometry.coordinates;
                createGeometry();
                animation();


            })

        }
        test();



    </script>
</body>

</html>