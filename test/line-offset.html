<!DOCTYPE html>
<html>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name=renderer content=webkit>
<script type="text/javascript" src="https://unpkg.com/@maptalks/geojson-bbox@1.0.4/dist/bbox.umd.js"></script>
<script type="text/javascript" src="https://unpkg.com/three@0.138.0/build/three.min.js"></script>
<script type="text/javascript" src="https://unpkg.com/three@0.142.0/examples/js/controls/OrbitControls.js"></script>
<script type="text/javascript" src="https://unpkg.com/poly-extrude/dist/poly-extrude.js"></script>
<script type="text/javascript" src="./util.js"></script>
<!-- <script type="text/javascript" src="http://localhost/geometry-extrude/dist/geometry-extrude.js"></script> -->

<style type="text/css">
    html,
    body {
        margin: 0px;
        height: 100%;
        width: 100%;
    }

    .container {
        width: 100%;
        height: 100%;
    }
</style>

<body>
    <script>
        const scene = createScene();

        function getTexture() {
            const texture = new THREE.TextureLoader().load('./data/road.jpg');
            texture.needsUpdate = true; //使用贴图时进行更新
            texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(1, 1);
            return texture;
        }

        const material = new THREE.MeshLambertMaterial({
            color: '#FFF',
            wireframe: false,
            vertexColors: false,
            map: getTexture(),
            side: 2
        })

        const lineMaterial1 = new THREE.LineBasicMaterial({ color: '#000' });
        const lineMaterial2 = new THREE.LineBasicMaterial({ color: 'red' });

        function createLine(coordinates, material) {
            const array = [];
            coordinates.forEach(c => {
                array.push(c[0], c[1], c[2] || 0);
            });
            const position = new Float32Array(array);
            const geometry = new THREE.BufferGeometry();
            // eslint-disable-next-line no-undef
            geometry.setAttribute('position', new THREE.BufferAttribute(position, 3));
            const line = new THREE.Line(geometry, material);
            return line;
        }


        function test() {

            getGeoJSON('./data/briges.geojson').then(geojson => {
                flatCoordinates(geojson);
                geojson.features.forEach(feature => {
                    let { type, coordinates } = feature.geometry;
                    if (!type.includes('LineString')) {
                        return;
                    }

                    if (type === 'LineString') {
                        coordinates = [coordinates];
                    }
                    coordinates.forEach(coordinate => {
                        coordinate.forEach(c => {
                            // c[2] = 0;
                        });
                        const line1 = createLine(coordinate, lineMaterial1);
                        scene.add(line1);

                        const time = 'time';
                        console.time(time);
                        [0.5, -0.5].forEach(offset => {
                            const result = polyextrude.polylineOffset(coordinate, { offset });
                            console.timeEnd(time);
                            // console.log(result);

                            const line2 = createLine(result, lineMaterial2);
                            scene.add(line2);
                        });

                    });


                });
            })
        }
        test();



    </script>
</body>

</html>